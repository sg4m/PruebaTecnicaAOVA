import streamlit as st
import sys
import os
import time

# Agregar el directorio src al path para importar nuestros m√≥dulos
sys.path.append(os.path.join(os.path.dirname(__file__), 'src'))

from src.utils.config import Config
from src.ai.gemini_client import GeminiClient
from src.ai.context_manager import ContextManager, MessageType
from src.audio.speech_to_text import SpeechToText
from src.audio.text_to_speech import TextToSpeech
from src.database.supabase_client import SupabaseClient
# from streamlit_audiorecorder import audiorecorder  # Comentado temporalmente

def inicializar_sesion():
    """Inicializar variables de sesi√≥n de Streamlit"""
    if 'conversation_history' not in st.session_state:
        st.session_state.conversation_history = []
    
    if 'lead_info' not in st.session_state:
        st.session_state.lead_info = {}
    
    # Inicializar cliente de Gemini
    if 'gemini_client' not in st.session_state:
        try:
            st.session_state.gemini_client = GeminiClient()
        except Exception as e:
            st.error(f"Error inicializando Gemini: {e}")
            st.session_state.gemini_client = None
    
    # Inicializar cliente de Speech-to-Text
    if 'speech_to_text' not in st.session_state:
        try:
            st.session_state.speech_to_text = SpeechToText()
        except Exception as e:
            st.error(f"Error inicializando Speech-to-Text: {e}")
            st.session_state.speech_to_text = None
    
    # Inicializar cliente de Text-to-Speech
    if 'text_to_speech' not in st.session_state:
        try:
            st.session_state.text_to_speech = TextToSpeech()
        except Exception as e:
            st.error(f"Error inicializando Text-to-Speech: {e}")
            st.session_state.text_to_speech = None
    
    # Inicializar cliente de base de datos
    if 'db_client' not in st.session_state:
        try:
            st.session_state.db_client = SupabaseClient()
            # Probar conexi√≥n
            if st.session_state.db_client.test_connection():
                st.session_state.db_connected = True
            else:
                st.session_state.db_connected = False
                st.session_state.db_client = None
        except Exception as e:
            st.warning(f"Base de datos no disponible: {e}")
            st.session_state.db_client = None
            st.session_state.db_connected = False
    
    # Inicializar Context Manager
    if 'context_manager' not in st.session_state:
        try:
            # Pasar cliente de BD al Context Manager
            st.session_state.context_manager = ContextManager(
                db_client=st.session_state.db_client if st.session_state.get('db_connected') else None
            )
            # Iniciar nueva conversaci√≥n si no existe
            if not hasattr(st.session_state, 'current_session_id'):
                session_id = st.session_state.context_manager.start_new_conversation()
                st.session_state.current_session_id = session_id
                print(f"‚úÖ Nueva conversaci√≥n iniciada: {session_id}")
        except Exception as e:
            st.error(f"Error inicializando Context Manager: {e}")
            st.session_state.context_manager = None

def mostrar_sidebar():
    """Mostrar la barra lateral con configuraciones y estado"""
    with st.sidebar:
        st.header("‚öôÔ∏è Configuraci√≥n")
        
        # Verificar configuraci√≥n
        try:
            Config.validate_config()
            st.success("‚úÖ Configuraci√≥n v√°lida")
            config_ok = True
        except ValueError as e:
            st.error(f"‚ùå Error en configuraci√≥n: {e}")
            config_ok = False
        
        # Estado de la base de datos
        st.markdown("### üóÑÔ∏è Base de Datos")
        if st.session_state.get('db_connected', False):
            st.success("‚úÖ Conectado a Supabase")
            
            # Mostrar estad√≠sticas b√°sicas
            if st.session_state.db_client:
                try:
                    stats = st.session_state.db_client.get_database_stats()
                    if stats:
                        st.metric("Leads Totales", stats.get('total_leads', 0))
                        st.metric("Conversaciones", stats.get('total_conversations', 0))
                        st.metric("Leads de Alta Calidad", stats.get('high_quality_leads', 0))
                except Exception as e:
                    st.error(f"Error obteniendo stats: {e}")
            
            # Bot√≥n para guardar conversaci√≥n actual
            if st.button("üíæ Guardar Conversaci√≥n"):
                if st.session_state.context_manager:
                    result = st.session_state.context_manager.save_conversation_to_db()
                    if result:
                        st.success("Conversaci√≥n guardada")
                    else:
                        st.error("Error guardando conversaci√≥n")
        else:
            st.warning("‚ö†Ô∏è Base de datos no disponible")
            st.caption("La aplicaci√≥n funciona sin BD")
        
        st.markdown("### üìä Estado del Agente")
        # Estado informativo basado en la disponibilidad de los servicios
        if (st.session_state.gemini_client and 
            st.session_state.speech_to_text and 
            st.session_state.text_to_speech):
            st.success("üü¢ Agente Operativo")
            st.caption("‚úÖ IA, STT y TTS funcionando")
        else:
            st.error("üî¥ Agente con Problemas")
            # Mostrar qu√© componentes fallan
            if not st.session_state.gemini_client:
                st.caption("‚ùå Error en cliente IA")
            if not st.session_state.speech_to_text:
                st.caption("‚ùå Error en Speech-to-Text")
            if not st.session_state.text_to_speech:
                st.caption("‚ùå Error en Text-to-Speech")
        
        # Informaci√≥n del lead actual - Vista mejorada
        st.markdown("### üë§ Informaci√≥n del Lead")
        if st.session_state.lead_info:
            # Mostrar an√°lisis de calidad si existe
            analisis = st.session_state.lead_info.get('analisis', {})
            if analisis:
                quality = analisis.get('quality_grade', '')
                score = analisis.get('score', 0)
                priority = analisis.get('priority', '')
                
                # Mostrar puntuaci√≥n con color seg√∫n calidad
                if score >= 80:
                    st.success(f"üî• {quality} ({score}/100)")
                elif score >= 60:
                    st.warning(f"üî∂ {quality} ({score}/100)")
                elif score >= 40:
                    st.info(f"‚ùÑÔ∏è {quality} ({score}/100)")
                else:
                    st.error(f"‚ùå {quality} ({score}/100)")
            
            # Informaci√≥n personal
            personal = st.session_state.lead_info.get('informacion_personal', {})
            if personal:
                st.markdown("**Informaci√≥n Personal:**")
                for key, value in personal.items():
                    if value:
                        st.text(f"‚Ä¢ {key.replace('_', ' ').title()}: {value}")
            
            # Informaci√≥n de contacto
            contacto = st.session_state.lead_info.get('contacto', {})
            if contacto:
                st.markdown("**Contacto:**")
                for key, value in contacto.items():
                    if value:
                        st.text(f"‚Ä¢ {key.replace('_', ' ').title()}: {value}")
            
            # Necesidades
            necesidades = st.session_state.lead_info.get('necesidades', {})
            if necesidades and necesidades.get('descripcion'):
                st.markdown("**Necesidades:**")
                st.text_area("", necesidades['descripcion'], height=60, disabled=True)
            
            # Informaci√≥n comercial
            comercial = st.session_state.lead_info.get('comercial', {})
            if comercial:
                st.markdown("**Informaci√≥n Comercial:**")
                for key, value in comercial.items():
                    if value and key != 'decision_maker':
                        st.text(f"‚Ä¢ {key.replace('_', ' ').title()}: {value}")
                        
            # Pr√≥ximos pasos recomendados
            if analisis and analisis.get('next_steps'):
                with st.expander("üìã Pr√≥ximos Pasos Recomendados"):
                    for i, step in enumerate(analisis['next_steps'], 1):
                        st.write(f"{i}. {step}")
                        
            # Informaci√≥n faltante
            if analisis and analisis.get('missing_info'):
                with st.expander("‚ùì Informaci√≥n Faltante"):
                    for info in analisis['missing_info']:
                        st.write(f"‚Ä¢ {info}")
        else:
            st.info("No hay informaci√≥n de lead capturada")
        
        # Estado del Context Manager  
        st.markdown("### üß† Contexto Inteligente")
        if st.session_state.context_manager and st.session_state.context_manager.current_context:
            ctx = st.session_state.context_manager.current_context
            col1, col2 = st.columns(2)
            
            with col1:
                st.metric("Fase", ctx.current_phase.value.title())
                st.metric("Interacciones", ctx.total_interactions)
            
            with col2:
                duration_min = int((time.time() - ctx.start_time) / 60)
                st.metric("Duraci√≥n", f"{duration_min} min")
                st.metric("Mensajes", len(ctx.messages))
            
            # Mostrar insights si hay
            insights = st.session_state.context_manager._generate_conversation_insights()
            if insights.get('engagement_level'):
                engagement_color = {"high": "üü¢", "medium": "üü°", "low": "üî¥"}
                level = insights['engagement_level']
                st.write(f"**Engagement:** {engagement_color.get(level, '‚ö™')} {level.title()}")
        
        # Estado del sistema TTS
        st.markdown("### üé§ Estado de Voz")
        if st.session_state.text_to_speech:
            tts_status = st.session_state.text_to_speech.get_tts_status()
            st.info(tts_status["message"])
            
            if tts_status["google_cloud"] == "no_configurado":
                with st.expander("üí° Mejorar calidad de voz"):
                    st.markdown("""
                    **Para obtener voz m√°s natural:**
                    1. üìñ Lee las instrucciones en `CONFIGURAR_TTS.md`
                    2. üîë Configura credenciales de Google Cloud
                    3. üéØ Disfruta de voz profesional
                    
                    **Actual:** Voz b√°sica (pyttsx3)  
                    **Con Google Cloud:** Voz natural profesional
                    """)
        
        # Estad√≠sticas
        st.markdown("### üìà Estad√≠sticas de Sesi√≥n")
        total_mensajes = len(st.session_state.conversation_history)
        mensajes_usuario = len([m for m in st.session_state.conversation_history if m['role'] == 'user'])
        mensajes_agente = len([m for m in st.session_state.conversation_history if m['role'] == 'assistant'])
        
        col1, col2 = st.columns(2)
        with col1:
            st.metric("Total", total_mensajes)
            st.metric("Usuario", mensajes_usuario)
        with col2:
            st.metric("Agente", mensajes_agente)
            st.metric("Datos", len(st.session_state.lead_info))
        
        # Configuraciones de voz
        st.markdown("### üó£Ô∏è Configuraci√≥n de Voz")
        if st.session_state.text_to_speech and st.session_state.text_to_speech.is_available():
            st.success("‚úÖ TTS Disponible")
            
            # Toggle para reproducci√≥n autom√°tica
            auto_speak = st.checkbox(
                "üîä Reproducir respuestas autom√°ticamente", 
                value=st.session_state.get('auto_speak', False),
                help="Reproduce las respuestas del agente autom√°ticamente"
            )
            st.session_state.auto_speak = auto_speak
            
            # Mostrar voces disponibles
            voices = st.session_state.text_to_speech.get_available_voices()
            if voices:
                st.info(f"üé§ Voces disponibles: {len(voices)}")
        else:
            st.warning("‚ö†Ô∏è TTS no disponible")
        
        # Botones de control
        st.markdown("### üéõÔ∏è Controles")
        if st.button("üóëÔ∏è Limpiar Conversaci√≥n", help="Eliminar todo el historial"):
            st.session_state.conversation_history = []
            st.session_state.lead_info = {}
            st.success("Conversaci√≥n limpiada")
            time.sleep(1)
            st.rerun()
        
        if st.button("üíæ Guardar Sesi√≥n", help="Guardar en base de datos"):
            st.info("Funci√≥n de guardado pendiente de implementar")
        
        return config_ok

def mostrar_conversacion():
    """Mostrar el historial de conversaci√≥n"""
    st.header("üí¨ Conversaci√≥n con el Lead")
    
    # Contenedor del chat
    chat_container = st.container()
    with chat_container:
        if st.session_state.conversation_history:
            for i, message in enumerate(st.session_state.conversation_history):
                if message['role'] == 'user':
                    with st.chat_message("user"):
                        st.write(f"**Usuario:** {message['content']}")
                else:
                    with st.chat_message("assistant"):
                        col1, col2 = st.columns([4, 1])
                        with col1:
                            st.write(f"**Agente IA:** {message['content']}")
                        with col2:
                            if st.button("üîä", key=f"speak_{i}", help="Reproducir respuesta"):
                                if st.session_state.text_to_speech and st.session_state.text_to_speech.is_available():
                                    with st.spinner("üó£Ô∏è Reproduciendo..."):
                                        success = st.session_state.text_to_speech.speak_text(message['content'])
                                        if not success:
                                            st.error("Error reproduciendo audio")
                                else:
                                    st.error("TTS no disponible")
        else:
            st.info("üëã ¬°Hola! Soy tu agente de IA especializado en lead generation. Puedes comunicarte conmigo escribiendo un mensaje o subiendo un archivo de audio.")
            st.markdown("""
            **¬øQu√© puedo hacer por ti?**
            - üìù Responder preguntas sobre productos/servicios
            - üîç Recopilar informaci√≥n sobre tus necesidades
            - üíº Ayudarte a encontrar la soluci√≥n perfecta
            - üìä Analizar tu perfil como prospecto
            """)

def procesar_mensaje(contenido, tipo="texto"):
    """Procesar mensaje del usuario y generar respuesta usando Gemini con contexto inteligente"""
    
    # Agregar mensaje del usuario al historial tradicional (para compatibilidad)
    st.session_state.conversation_history.append({
        'role': 'user',
        'content': contenido,
        'tipo': tipo
    })
    
    # Agregar mensaje al Context Manager
    if st.session_state.context_manager:
        message_type = MessageType.USER_AUDIO if tipo == "audio" else MessageType.USER_TEXT
        st.session_state.context_manager.add_message('user', contenido, message_type)
        
        # Analizar y actualizar fase de conversaci√≥n
        st.session_state.context_manager.analyze_conversation_phase()
        st.session_state.context_manager.update_conversation_summary()
    
    # Verificar si Gemini est√° disponible
    if st.session_state.gemini_client is None:
        respuesta = "Lo siento, hay un problema con la conexi√≥n a Gemini. Por favor verifica tu configuraci√≥n."
    else:
        try:
            # Generar respuesta usando Gemini con contexto inteligente
            respuesta = st.session_state.gemini_client.generate_response(
                contenido,
                context=st.session_state.conversation_history[:-1],  # Fallback
                context_manager=st.session_state.context_manager  # Contexto inteligente
            )
            
            # Extraer informaci√≥n del lead usando el sistema avanzado
            if len(st.session_state.conversation_history) >= 2:  # Al menos una interacci√≥n completa
                try:
                    # Extraer informaci√≥n detallada del lead
                    extracted_info = st.session_state.gemini_client.extract_lead_info(
                        st.session_state.conversation_history
                    )
                    
                    # Actualizar informaci√≥n del lead
                    if extracted_info:
                        st.session_state.lead_info = extracted_info
                        
                        # Actualizar informaci√≥n en el Context Manager
                        if st.session_state.context_manager:
                            st.session_state.context_manager.update_lead_info(extracted_info)
                        
                        # Analizar calidad del lead
                        lead_analysis = st.session_state.gemini_client.analyze_lead_quality(extracted_info)
                        st.session_state.lead_info['analisis'] = lead_analysis
                        
                        # Mostrar notificaci√≥n si es un lead de alta calidad
                        score = lead_analysis.get('score', 0)
                        if score >= 80:
                            st.success(f"üéØ Lead de alta calidad detectado! Puntuaci√≥n: {score}/100")
                        elif score >= 60:
                            st.info(f"üìä Lead potencial identificado. Puntuaci√≥n: {score}/100")
                        
                except Exception as e:
                    print(f"Error extrayendo informaci√≥n: {e}")
            
        except Exception as e:
            print(f"Error procesando con Gemini: {e}")
            respuesta = "Disculpa, tuve un problema t√©cnico. ¬øPodr√≠as repetir tu mensaje?"
    
    # Agregar respuesta del agente al historial tradicional
    st.session_state.conversation_history.append({
        'role': 'assistant', 
        'content': respuesta,
        'timestamp': time.time()
    })
    
    # Agregar respuesta al Context Manager
    if st.session_state.context_manager:
        st.session_state.context_manager.add_message('assistant', respuesta, MessageType.AGENT_RESPONSE)
    
    # Reproducir respuesta autom√°ticamente (opcional)
    if st.session_state.get('auto_speak', False) and st.session_state.text_to_speech:
        try:
            st.session_state.text_to_speech.speak_text(respuesta)
        except Exception as e:
            print(f"Error reproduciendo respuesta autom√°tica: {e}")

def mostrar_controles_input():
    """Mostrar controles para enviar mensajes"""
    st.header("üéôÔ∏è Env√≠a tu Mensaje")
    
    # Pesta√±as para diferentes tipos de input
    tab1, tab2 = st.tabs(["üìù Texto", "üéµ Audio"])
    
    with tab1:
        st.markdown("### Escribe tu mensaje")
        texto_input = st.text_area(
            "¬øEn qu√© puedo ayudarte hoy?",
            placeholder="Ejemplo: Hola, me interesa conocer sus servicios de marketing digital...",
            height=100
        )
        
        if st.button("üì§ Enviar Mensaje", type="primary", key="enviar_texto"):
            if texto_input.strip():
                with st.spinner("Procesando mensaje..."):
                    procesar_mensaje(texto_input.strip(), "texto")
                    st.success("‚úÖ Mensaje enviado")
                    time.sleep(0.5)
                    st.rerun()
            else:
                st.warning("‚ö†Ô∏è Por favor escribe un mensaje.")
    
    with tab2:
        # Sub-pesta√±as para diferentes tipos de audio
        audio_tab1, audio_tab2 = st.tabs(["ÔøΩ Subir Audio", "üé§ Grabar Audio"])
        
        with audio_tab1:
            st.markdown("### Sube un archivo de audio")
            st.info("üí° **Recomendaci√≥n**: Usa archivos WAV para mejor compatibilidad. Para MP3/M4A necesitas FFmpeg instalado.")
            
            uploaded_audio = st.file_uploader(
                "Selecciona un archivo de audio",
                type=['wav', 'mp3', 'ogg', 'm4a'],
                help="Formatos soportados: WAV (recomendado), MP3, OGG, M4A"
            )
        
        if uploaded_audio is not None:
            st.audio(uploaded_audio, format=uploaded_audio.type)
            st.success(f"‚úÖ Archivo cargado: {uploaded_audio.name}")
            
            if st.button("üéØ Procesar Audio", type="primary", key="procesar_audio"):
                if st.session_state.speech_to_text is None:
                    st.error("‚ùå Sistema de transcripci√≥n no disponible")
                else:
                    with st.spinner("üîÑ Transcribiendo audio..."):
                        # Transcribir audio real
                        texto_transcrito = st.session_state.speech_to_text.transcribe_audio_file(uploaded_audio)
                        
                        if texto_transcrito and not texto_transcrito.startswith("Error") and not texto_transcrito.startswith("No se pudo"):
                            # Mostrar transcripci√≥n
                            st.success(f"üìù Transcripci√≥n: {texto_transcrito}")
                            
                            # Procesar mensaje
                            procesar_mensaje(texto_transcrito, "audio")
                            st.success("‚úÖ Audio transcrito y procesado")
                            time.sleep(0.5)
                            st.rerun()
                        else:
                            st.error(f"‚ùå {texto_transcrito}")
        
        with audio_tab2:
            st.markdown("### Grabaci√≥n desde micr√≥fono")
            
            # Verificar si hay micr√≥fono disponible
            if st.session_state.speech_to_text and st.session_state.speech_to_text.is_microphone_available():
                st.success("üé§ Micr√≥fono detectado")
                
                # Configuraci√≥n de grabaci√≥n
                col1, col2 = st.columns(2)
                with col1:
                    timeout = st.slider("Tiempo de grabaci√≥n (segundos)", 3, 10, 5)
                with col2:
                    st.write("")  # Espaciado
                
                if st.button("üé§ Empezar Grabaci√≥n", type="primary", key="record_audio"):
                    if st.session_state.speech_to_text is None:
                        st.error("‚ùå Sistema de transcripci√≥n no disponible")
                    else:
                        # Grabar y transcribir desde micr√≥fono
                        texto_transcrito = st.session_state.speech_to_text.transcribe_microphone(timeout)
                        
                        if texto_transcrito and not texto_transcrito.startswith("Error") and not texto_transcrito.startswith("No se pudo") and not texto_transcrito.startswith("Tiempo"):
                            # Mostrar transcripci√≥n
                            st.success(f"üìù Transcripci√≥n: {texto_transcrito}")
                            
                            # Procesar mensaje
                            procesar_mensaje(texto_transcrito, "audio_live")
                            st.success("‚úÖ Audio grabado, transcrito y procesado")
                            time.sleep(0.5)
                            st.rerun()
                        else:
                            st.warning(f"‚ö†Ô∏è {texto_transcrito}")
            else:
                st.warning("‚ö†Ô∏è No se detect√≥ micr√≥fono o el sistema de audio no est√° disponible")
                st.info("üí° Aseg√∫rate de que tu micr√≥fono est√© conectado y funcionando")

def mostrar_panel_analisis_lead():
    """Mostrar panel detallado de an√°lisis de lead"""
    if not st.session_state.lead_info:
        return
        
    analisis = st.session_state.lead_info.get('analisis', {})
    if not analisis:
        return
    
    # Panel expandible con an√°lisis detallado
    with st.expander("üìä An√°lisis Detallado del Lead", expanded=False):
        col1, col2 = st.columns([1, 1])
        
        with col1:
            st.markdown("### üéØ Evaluaci√≥n de Calidad")
            score = analisis.get('score', 0)
            quality = analisis.get('quality_grade', '')
            
            # M√©trica y barra de progreso
            st.metric("Puntuaci√≥n Total", f"{score}/100")
            st.progress(score/100)
            st.write(f"**Clasificaci√≥n:** {quality}")
            
            # Fortalezas del lead
            strengths = analisis.get('strengths', [])
            if strengths:
                st.markdown("### ‚úÖ Fortalezas")
                for strength in strengths:
                    st.write(f"‚Ä¢ {strength}")
        
        with col2:
            # Preocupaciones
            concerns = analisis.get('concerns', [])
            if concerns:
                st.markdown("### ‚ö†Ô∏è Preocupaciones")
                for concern in concerns:
                    st.write(f"‚Ä¢ {concern}")
            
            # Informaci√≥n faltante
            missing = analisis.get('missing_info', [])
            if missing:
                st.markdown("### ‚ùì Informaci√≥n Pendiente")
                for item in missing:
                    st.write(f"‚Ä¢ {item}")
        
        # Pr√≥ximos pasos recomendados
        next_steps = analisis.get('next_steps', [])
        if next_steps:
            st.markdown("### üìã Plan de Acci√≥n Recomendado")
            for i, step in enumerate(next_steps, 1):
                st.write(f"{i}. {step}")

def main():
    """Funci√≥n principal de la aplicaci√≥n"""
    # Configuraci√≥n de la p√°gina
    st.set_page_config(
        page_title="AI Agent de Voz - Lead Generation",
        page_icon="üé§",
        layout="wide",
        initial_sidebar_state="expanded"
    )
    
    # Inicializar sesi√≥n
    inicializar_sesion()
    
    # T√≠tulo principal con estilo
    st.markdown("""
    # üé§ AI Agent de Voz para Lead Generation
    ### *Convierte conversaciones en oportunidades de negocio*
    """)
    st.markdown("---")
    
    # Mostrar sidebar y verificar configuraci√≥n
    config_ok = mostrar_sidebar()
    
    if not config_ok:
        st.error("‚ö†Ô∏è La aplicaci√≥n no puede funcionar sin una configuraci√≥n v√°lida. Revisa las variables de entorno en el archivo .env")
        st.stop()
    
    # Panel de an√°lisis de lead (si hay informaci√≥n)
    mostrar_panel_analisis_lead()
    
    # Layout principal
    col1, col2 = st.columns([2, 1], gap="large")
    
    with col1:
        mostrar_conversacion()
    
    with col2:
        mostrar_controles_input()
    
    # Footer con informaci√≥n
    st.markdown("---")
    st.markdown("""
    <div style='text-align: center; color: #666;'>
        <p><strong>üöÄ AI Agent v1.0</strong></p>
        <p>Powered by Streamlit ‚Ä¢ Google Gemini ‚Ä¢ Supabase</p>
        <p><em>Estado actual: MVP - Interfaz b√°sica funcionando</em></p>
    </div>
    """, unsafe_allow_html=True)

if __name__ == "__main__":
    main()
